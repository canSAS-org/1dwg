<HTML>
  <HEAD>
  </HEAD>
  <BODY>
    <PRE>
FUNCTION CS_XmlReader(fileName)
	//
	// open a canSAS 1-D reduced SAS XML data file
	//	returns:
	//		0 : successful
	//		-1: XML file not found
	//		-2: root element is not <SASroot>
	//		-3: <SASroot> version  is not 1.0
	//		-4: no <SASentry> elements
	//
	STRING fileName
	STRING origFolder
	STRING workingFolder = "root:Packages:CS_XMLreader"
	VARIABLE returnCode
FUNCTION CS_1i_parseXml(fileID)
FUNCTION CS_1i_collectMetadata(fileID, sasEntryPath)
FUNCTION CS_fileExists(fileName)
FUNCTION CS_appendMetaData(key, xpath, value)
FUNCTION CS_findElementIndex(matchStr)
FUNCTION CS_registerNameSpaces()
FUNCTION/S CS_GetNameSpaceByKey(key)
FUNCTION/S CS_GetKeyByNameSpace(ns)
FUNCTION/S CS_XPath_NS(simpleStr)
	// this function adds namespace info as necessary to simpleStr (an XPath)
FUNCTION/S CS_buildXpathStr(prefix, value)
	// this function can be used only with very simple XPath constructions
FUNCTION/S CS_XmlStrFmXpath(fileID, prefix, value)
FUNCTION CS_simpleXmlWaveFmXpath(fileID, prefix, value)
FUNCTION CS_simpleXmlListXpath(fileID, prefix, value)
Function/T   TrimWS(str)
Function/T   TrimWSL(str)
Function/T   TrimWSR(str)
FUNCTION CS_updateWaveNote(wavName, key, value)
FUNCTION CS_1i_extractIdataColumn2Wave(fileID, basePath, colName, wavName)
	// this function pulls one column of data from each <Idata> element
	// easier to write this as a function than debug it all the times it is needed
	//
	// avoid the use os the semicolon in anything that might make it into
	//	the IgorPro wavenote since the semicolon is a list delimiter.
	// The import macro defends against this by converting all semicolons
	//	into the string " :semicolon: "
FUNCTION CS_1i_extractSasData(fileID, SASdataPath, SASdata_folder)
	//  (1i in the function name signifies this is a function that supports INPUT from version 1.0 XML files)
FUNCTION prj_grabMyXmlData()
FUNCTION prjTest_cansas1d()
    </PRE>
  </BODY>
</HTML>

